ttf text

https://github.com/libsdl-org/SDL_ttf/blob/main/examples/testgputext.c


... init 

import ttf "vendor:sdl3/ttf"

init_text :: proc()
{
	// SDL_GPUSamplerCreateInfo sampler_info = {
    //     .min_filter = SDL_GPU_FILTER_LINEAR,
    //     .mag_filter = SDL_GPU_FILTER_LINEAR,
    //     .mipmap_mode = SDL_GPU_SAMPLERMIPMAPMODE_LINEAR,
    //     .address_mode_u = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE,
    //     .address_mode_v = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE,
    //     .address_mode_w = SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE
    // };
    // context.sampler = check_error_ptr(SDL_CreateGPUSampler(context.device, &sampler_info));

	// check_error_bool(TTF_Init());
    // TTF_Font *font = check_error_ptr(TTF_OpenFont(font_filename, 50)); /* Preferably use a Monospaced font */
    // if (!font) {
    //     running = false;
    // }
    // SDL_Log("SDF %s", use_SDF ? "enabled" : "disabled");
    // TTF_SetFontSDF(font, use_SDF);
    // TTF_SetFontWrapAlignment(font, TTF_HORIZONTAL_ALIGN_CENTER);
    // TTF_TextEngine *engine = check_error_ptr(TTF_CreateGPUTextEngine(context.device));

    // char str[] = "     \nSDL is cool";
    // TTF_Text *text = check_error_ptr(TTF_CreateText(engine, font, str, 0));
}

... draw

render_text :: proc()
{
    TTF_SetTextString(text, str, 0);

    int tw, th;
    check_error_bool(TTF_GetTextSize(text, &tw, &th));

    ...

    model = SDL_MatrixMultiply(model, SDL_MatrixTranslation((SDL_Vec3){ -tw / 2.0f, th / 2.0f, 0.0f }));
    matrices[1] = model;

    // Get the text data and queue the text in a buffer for drawing later
    TTF_GPUAtlasDrawSequence *sequence = TTF_GetGPUTextDrawData(text);
    queue_text(&geometry_data, sequence, &colour);

    set_geometry_data(&context, &geometry_data);

    context.cmd_buf = check_error_ptr(SDL_AcquireGPUCommandBuffer(context.device));
    transfer_data(&context, &geometry_data);
    draw(&context, matrices, 2, sequence);

    ... (draw function above)

    int index_offset = 0, vertex_offset = 0;
    for (TTF_GPUAtlasDrawSequence *seq = draw_sequence; seq != NULL; seq = seq->next) {
        SDL_BindGPUFragmentSamplers(
            render_pass, 0,
            &(SDL_GPUTextureSamplerBinding){
                .texture = seq->atlas_texture, .sampler = context->sampler },
            1);

        SDL_DrawGPUIndexedPrimitives(render_pass, seq->num_indices, 1, index_offset, vertex_offset, 0);

        index_offset += seq->num_indices;
        vertex_offset += seq->num_vertices;
    }

    ...

    SDL_SubmitGPUCommandBuffer(context.cmd_buf);
}

void queue_text_sequence(GeometryData *geometry_data, TTF_GPUAtlasDrawSequence *sequence, SDL_FColor *colour)
{
    for (int i = 0; i < sequence->num_vertices; i++) {
        Vertex vert;
        const SDL_FPoint pos = sequence->xy[i];
        vert.pos = (Vec3){ pos.x, pos.y, 0.0f };
        vert.colour = *colour;
        vert.uv = sequence->uv[i];

        geometry_data->vertices[geometry_data->vertex_count + i] = vert;
    }

    SDL_memcpy(geometry_data->indices + geometry_data->index_count, sequence->indices, sequence->num_indices * sizeof(int));

    geometry_data->vertex_count += sequence->num_vertices;
    geometry_data->index_count += sequence->num_indices;
}

void queue_text(GeometryData *geometry_data, TTF_GPUAtlasDrawSequence *sequence, SDL_FColor *colour)
{
    for ( ; sequence; sequence = sequence->next) {
        queue_text_sequence(geometry_data, sequence, colour);
    }
}

void set_geometry_data(Context *context, GeometryData *geometry_data)
{
    Vertex *transfer_data = SDL_MapGPUTransferBuffer(context->device, context->transfer_buffer, false);

    SDL_memcpy(transfer_data, geometry_data->vertices, sizeof(Vertex) * geometry_data->vertex_count);
    SDL_memcpy(transfer_data + MAX_VERTEX_COUNT, geometry_data->indices, sizeof(int) * geometry_data->index_count);

    SDL_UnmapGPUTransferBuffer(context->device, context->transfer_buffer);
}
