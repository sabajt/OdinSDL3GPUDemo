#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct Vertex
{
    float4 color;
    float2 position;
    float2 padding;
};

struct type_StructuredBuffer_Vertex
{
    Vertex _m0[1];
};

struct Model
{
    packed_float3 position;
    float rotation;
    float2 scale;
    float2 padding;
};

struct type_StructuredBuffer_Model
{
    Model _m0[1];
};

struct type_ViewProjection
{
    float4x4 view_projection;
};

struct main0_out
{
    float4 out_var_TEXCOORD0 [[user(locn0)]];
    float2 out_var_TEXCOORD1 [[user(locn1)]];
    float2 out_var_TEXCOORD2 [[user(locn2)]];
    float2 out_var_TEXCOORD3 [[user(locn3)]];
    float4 gl_Position [[position]];
};

struct main0_in
{
    uint in_var_TEXCOORD0 [[attribute(0)]];
    uint in_var_TEXCOORD1 [[attribute(1)]];
};

vertex main0_out main0(main0_in in [[stage_in]], constant type_ViewProjection& ViewProjection [[buffer(0)]], const device type_StructuredBuffer_Vertex& VertexBuffer [[buffer(1)]], const device type_StructuredBuffer_Model& ModelBuffer [[buffer(2)]])
{
    main0_out out = {};
    float _60 = cos(ModelBuffer._m0[in.in_var_TEXCOORD1].rotation);
    float _61 = sin(ModelBuffer._m0[in.in_var_TEXCOORD1].rotation);
    float4 _75 = ViewProjection.view_projection * float4((float2x2(float2(_60, _61), float2(-_61, _60)) * (VertexBuffer._m0[in.in_var_TEXCOORD0].position * ModelBuffer._m0[in.in_var_TEXCOORD1].scale)) + float2(ModelBuffer._m0[in.in_var_TEXCOORD1].position[0], ModelBuffer._m0[in.in_var_TEXCOORD1].position[1]), ModelBuffer._m0[in.in_var_TEXCOORD1].position[2], 1.0);
    out.gl_Position = _75;
    out.out_var_TEXCOORD0 = VertexBuffer._m0[in.in_var_TEXCOORD0].color;
    out.out_var_TEXCOORD1 = _75.xy;
    out.out_var_TEXCOORD2 = float2(ModelBuffer._m0[in.in_var_TEXCOORD1].position[0], ModelBuffer._m0[in.in_var_TEXCOORD1].position[1]);
    out.out_var_TEXCOORD3 = ModelBuffer._m0[in.in_var_TEXCOORD1].scale;
    return out;
}

